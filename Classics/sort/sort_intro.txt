						四种基本排序算法简介
	1.快速排序法(Quick Sort)：
    通过一趟扫描将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序。整个排序过程可以递归进行，以此达到整个数据变成有序序列的目的。
快速排序是一种划分交换排序,它采用了一种分治的策略,通常称其为分治法。
    分治法的基本思想是将原问题分为若干规模更小但结构与原问题相似的子问题,递归地解这些子问题。然后将这些子问题的解组合为原问题的解。
    快速排序的基本思想，通过一步排序将待排序的数据分割成独立的两部分，其中一部分的数据比另一部分数据小。
然后分别对这两部分数据继续进行划分、排序，直至整个序列有序。基准元素可选择第一个或最后一个或中间一个或随机一个。
    对于序列a[1..r]，快速排序分三步：
1.分解--将a[1..r]分解成两个非空子序列a[1..q]和a[q+1..r],使午a[1..q]中的数据小于a[q+1..r]中的数
2.递归求解。通过递归调用快速排序对左、右子区间a[1..q]和a[q+1..r]快速排序。
3.合并。由于分解是原地进行的分解和递归求解后不需要做任何其他操作a[1..r]的排序完。
    下图展示了一次划分的过程及整个快速排序的过程。方框表示基准元素，它未参加真正的交换，只是在划分完成时才将它放入正确的位置上。一次划分过程
初始序列              12    8     10     14      6      2 
选定基准元素          12    8     10     14      6      2
                       I                                j
自j起向左扫描         12    8     10     14      6      2
                      I                                 j 
第一次交换后         2     8     10     14      6      12
                            I                            j
自i起向右扫描        2     8      10     14      6      12
                            I                             j
I向右扫描            2     8      10     14      6      12
                                    I                     j
I向右扫描            2     8      10     14      6      12
                                           I              j
第二次交换后         2     8      10     12      6      14
                                          I       j 
自j起向右扫描        2     8      10     12      6      14
                                          I       j
第三次交换后         2     8      10     6      12      14
                                                 Ij  
各步排序之后的状态 
初始假设          [  12         8          10        14         6          2 ] 
一步排序后                     8          10         6  ]      12        [ 14 ] 
二步排序后          2      [   8          10         6  ]      12         14 
三步排序后          2       [  6  ]        8      [ 10  ]      12         14 
最后的排序结果      2         6           8        10         12         14

算法评价
快速排序的时间主要耗费在划分操作上，对长度为r的区间进行划分，共需r-1次数据的比较。
(1)最坏时间复杂度：最坏情况是每次划分选取的基准都是当前无序区中关键字最小(或最大)的记录。划分的结果是基准左边的子区间为空(或右边的子区间为空),而划分所得的另一个非空的子区间中记录数目,仅仅比划分前的无序区中记录个数少一个。
因此，快速排序必须做n-1次划分,第i次划分开始区间长度为n-i+1,所需的比较次数为n-i(1<=i<=n-1),故总的比较次数达到最大值Cmax=n(n-1)/2=O(n2);
(2)最好时间复杂度：在最好情况下，每次划分所取的基准都是当前无序区的"中值"记录。划分的结果是基准的左、右两个无序子区间的长充大致相等。总的关键字比较次数为O(nlgn)。
(3)平均时间复杂度：尽管快速排序的最坏时间为O(n2)，但就平均性而言，它是基于关键字比较的内部排序算法中速度最快者。快速排序亦因此而得名，它的平均时间复杂度为O(nlogn)。


	2.冒泡排序法(Bubble Sort):
    原理是临近的数字两两进行比较,按照从小到大或者从大到小的顺序进行交换，这样一趟过去后,最大或最小的数字被交换到了最后一位，然后再从头开始进行两两比较交换，直到倒数第二位时结束。

 --
 12     2      2      2      2       2
 	   --
 8      12     6      6      6       6
 		  --
 10     8      12     8      8       8
 			 --
 14     10     8      12     10      10
 				--
 6      14     10     10     12      12
 					
 2      6      14     14     14      14
 --    --      --     --     --      
初      第     第     第      第      第   
始      一     二     三      四      五    
数      步     步     步      步      步    
据      排     排     排      排      排           
        序     序     序      序      序           
        后     后     后      后      后

算法评价
1,算法的最好时间复杂度
    若数据的初始状态是正序的，一步扫描即可完成排序，所需的数据比较次数C和数据移动次数均达到最小值 
    Cmin=n-1
    Mmin=0;
    冒泡排序的最好时间复杂度为O(n)。 
2,算法的最坏时间复杂度 
    若数据是反序的，需要进行n-1步排序。每步排序要进行n-i次数据的比较
    1<=i<=n-i
    且每次比较都必须移动数据三次来达到交换数据位置。在这种情况下,比较和移动次数均达到最大值 
    Cmax=n(n-1)/2=O(n2)
    Mmax=3n(n-1)/2=O(n2)
    冒泡排序的最坏时间复杂度为O(n2) 
3,算法的平时间复杂度为O(n2)。虽然冒泡排序不一定要进行n-1步，但由于它的数据移动次数较多，故平均时间性能比直接插入排序差得多。 
4,算法稳定性。冒泡排序是就地排序序，且它是稳定的


	3.选择排序法(Selection Sort)
   直接从待排序数组里选择一个最小（或最大）的数字，每次都拿一个最小数字出来，顺序放入新数组，直到全部拿完。
 初始状态      [ 12            8         10           14             6             2  ] 
 第一步排序     2           [  8         10           14             6             12 ] 
 第二步排序     2             6        [ 10           14             8             12 ] 
 第三步排序     2             6          8          [ 14             10            12 ] 
 第四步排序     2             6          8           10            [ 14            12 ] 
 第五步排序     2             6          8           10             12            14 

算法评价
1.数据比较次数：无论数据序列初始状态如何，在第i步排序中选出最小数据，需做n-i次比较。因此，总的比较次数为n(n-1)/2=O(n2); 
2.数据的移动次数：当初始数据序列为正序时，移动次数为0。数据序列初态为反序时，每步排序均要执行交换操作，总的移动次数取最大值3(n-1)。直接选择排序的平均时间复杂度为O(n2);
3.稳定性分析：直接选择排序是不稳定的。


	4.插入排序(Insertion Sort)
    插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。
    将待排序的数据分成两个区域，有序区和无序区。每次将一个无序区中的数据按其大小插入到有序区中的适当位置，直到所有无序区中的数据都插入完成为止。
设待排序的数据有6个：依次为12、8、10、14、6、2.其排序过程如图所示
循环变量I     12     8     10      14     6      2    
I=1         [12 ]    8     10      14    6       2    
I=2         [8      12 ]   10      14    6       2    
I=3         [8      10    12  ]   14     6       2    
I=4         [8      10    12      14]    6       2    
I=5         [6      8     10      12    14 ]     2    
I=6         [2      6     8       10    12      14]

算法评价
    不难发现，随数据的初始状态不同，插入排序所耗时间有很大差异。当数据的初始状态为正序，在每一步排序中仅需进行一次数据比较，且不发生数据记录的移动，即最小比较次数为n-1次。此时算法的复杂度为O(n)。当数据初始状态为反序时,则数据记录的比较次数和移动次都取最大值,即最大比较次数(2+3+4+...+n)=(n-1)(n+2)/2,最大移动次数为(n+4)(n-1)/2。取上述最小值和最大值的平均值，作为插入排序时所需进行关键字间的比较次数和移动记录的次数，约为n2/4。由此，插入排序算法的时间复杂度为O(n2)。
    插入排序法简便且容易实现，当待排数据量n很小时，这是一种很好的排序方法。但当n变大时，插入排序的时间开销不断增大。插入排序适用于大部分数据已形成正序或反序，只需插入个别数据的情况。 


	5.希尔排序
    先取一个正整数d1<n，把所有序号相隔d1的数组元素放一组，组内进行直接插入排序；然后取d2<d1，重复上述分组和排序操作；直至di=1，即所有记录放进一个组中排序为止
    算法思想简单描述
    在直接插入排序算法中，每次插入一个数，使有序序列只增加1个节点，并且对插入下一个数没有提供任何帮助。如果比较相隔较远距离(称为增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。
    希尔排序是不稳定的。

初始：d=5
49 38 65 97 76 13 27 49* 55 04
49 13
|-------------------|
38 27
|-------------------|
65 49*
|-------------------|
97 55
|-------------------|
76 04
|-------------------|
一趟结果
13 27 49* 55 04 49 38 65 97 76
d=3
13 27 49* 55 04 49 38 65 97 76
13 55 38 76
|------------|------------|------------|
27 04 65
|------------|------------|
49* 49 97
|------------|------------|
二趟结果
13 04 49* 38 27 49 55 65 97 76
d=1
13 04 49* 38 27 49 55 65 97 76
|----|----|----|----|----|----|----|----|----|
三趟结果
04 13 27 38 49* 49 55 65 76 97



	6.归并排序
    原理,把原始数组分成若干子数组,对每一个子数组进行排序,继续把子数组与子数组合并,合并后仍然有序,直到全部合并完,形成有序的数组

举例
无序数组[6 2 4 1 5 9]
先看一下每个步骤下的状态,完了再看合并细节
第一步 [6 2 4 1 5 9]原始状态
第二步 [2 6] [1 4] [5 9]两两合并排序,排序细节后边介绍
第三步 [1 2 4 6] [5 9]继续两组两组合并
第四步 [1 2 4 5 6 9]合并完毕,排序完毕
输出结果[1 2 4 5 6 9]

合并细节
详细介绍第二步到第三步的过程,其余类似
第二步:[2 6] [1 4] [5 9]
两两合并,其实仅合并[2 6] [1 4],所以[5 9]不管它,
原始状态
第一个数组[2 6]
第二个数组[1 4]
--------------------
第三个数组[...]

第1步,顺序从第一,第二个数组里取出一个数字:2和1
比较大小后将小的放入第三个数组,此时变成下边这样
第一个数组[2 6]
第二个数组[4]
--------------------
第三个数组[1]
 
第2步,继续刚才的步骤,顺序从第一,第二个数组里取数据,2和4,
同样的比较大小后将小的放入第三个数组,此时状态如下
第一个数组[6]
第二个数组[4]
--------------------
第三个数组[1 2]
 
第3步,再重复前边的步骤变成,将较小的4放入第三个数组后变成如下状态
第一个数组[6]
第二个数组[...]
--------------------
第三个数组[1 2 4]
 
第4步,最后将6放入,排序完毕
第一个数组[...]
第二个数组[...]
--------------------
第三个数组[1 2 4 6]
 
[ 1 2 4 6 ]与[ 5 9 ]的合并过程与上边一样,不再分解
